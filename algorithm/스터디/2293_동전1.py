# 동전1 아이디어 정리

# K와 동전리스트가 주어진다.
# for문을 돌려서 K를 동전으로 나눈 몫을 본다.
# ( 나머지도 쓰나? )
# 어떤 아이디어.
# a,b가 나오잖아
# b가 0이 아니면, 다음 코인에서 b 반복하면
# 몫이 나오나?

# 1 2 5 일때

# 5 : 2
# 2 : 5
# 1 : 10
# 인데
# 5를 2개 쓸 때
# 5를 1개 쓸 때
# 5를 0개 쓸 때
# 3 가지 경우로 나뉘고
# 그 안에서 다시

# 5 = 2
# 1) 5를 2개 쓰고 끝

# 5 = 1
# 1 ) 2를 2개 쓸 때
# 2 ) 2를 1개 쓸 때
# 3 ) 2를 0개 쓸 때

# 5 = 0
# 2를 5개 쓸 때
# 2를 4개 쓸 때
# 2를 3개 쓸 때
# 2를 2개 쓸 때
# 2를 1개 쓸 때
# 2를 0개 쓸 때
# 이렇게 나뉘는 거.

# DP[i] 를 구하는 규칙을 찾아보자.
# 1로 채울 수 있는 경우의 수 = 1개
# 2일 때는, 11 과 2 로 2개
# 3일 때는, 111 과 2 1 로 2개. ? 맞나? 맞다. (순열 X 조합임)
# 4일 때는 1111과 22와 112로 3개. 지금까지 1, 2, 2, 3 (2의 배수일 때 하나씩 늘어남)
# 5일 때는 11111과 122와 1112와 5로 4개. 지금까지 1 2 2 3 4 # 5의 배수라서 하나 늘어남
# 다이나믹프로그래밍이니까, 이전 항들을 이용해서 구할 수 있어야 함
# 만약 5라면, 2를 하나 빼면 3에 있는 항과 같음. 거기에 5가 있는 케이스가 추가된 거. 3일 때는 2개, 거기에 2 추가한거 하나, 5인 거 하나 해서 4개
# 만약 9일 때를 생각해볼까? 2의 입장에서는 9에서 2를 뺀 7의 경우를 봐야할 듯. 거기에 2를 추가한 경우 하나가 추가된거니까
# 5의 입장에서는 9에서 5를 뺀 4의 경우를 봄. 4에다가 5 하나 추가하면 9니까.
# 6의 입장에선, 111111, 11112, 1122, 222, 15 해서 5개
# 7의 경우를 세보면, 1111111, 111112, 11122, 1222, 115, 25 6개
# 8의 경우를 세보면, 11111111, 1111112, 111122, 11222, 2222, 1115, 125 이렇게 7개?
# 1만 있는 경우 1개, 2가 섞인 경우 4개(5는 따로) 5가 섞인 경우 2개 해서 7개.
# 결국 1의 경우 변함이 없음 / 2의 경우 6에 있는 2가 섞인 케이스에서 하나가 늘어남 / 5는...? 3일 때보다 하나 늘어난건가?
# 9의 경우를 세보면, 111111111, 11111112, 1111122, 111222, 12222, 11115, 1125, 225 8개?
# 예시가 10이니까, 10의 경우도 살펴보자.
# 1로 채우는 경우 1개
# 2로 채우는 경우 7개?                   

N, M = map(int, input().split())
coins = []
for _ in range(N):
    a = int(input())
    if a <= M:
        coins.append(a)
coins.sort()

DP = [1] + ([0] * M)

for coin in coins:
    for i in range(1,M+1):
        if i-coin >=0 :
            DP[i] = DP[i] + DP[i-coin]
print(DP[M])