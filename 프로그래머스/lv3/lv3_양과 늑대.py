# 기본적인 아이디어 적어놓기
# 기본적으로 0번 노드에서 이을 수 있는 양 부터 잇는다.(ㅇㅋ)
# 그런 다음 어떻게 할 지를 생각해본다.
# 방법 1. BFS로 노드 돌기. (x) 구상해보니 DFS가 맞을 듯? 최고깊이가 중요해...
# 방법 1 좀 재밌을수도? 아이디어는
# 1. 처음부터 이을 수 있는 양을 다 잇는다.
# 2. 그런 후, 다른 이어져있는 노드들(늑대들이겠지? 양은 다 이었으니)을 stack에 넣는다.
# DFS 시전하기
# 어음 이게 맞을라나?
# 개같이 틀릴듯. 아이디어를 좀 더 끌어올려야 됨
# 트리를 어떻게 순회시킬까에 대한 아이디어.
# 근데 이거 여러 경우를 다 판단하는 거 밖에 없다.
# 그래서 깊이우선을 해서 '양을 만날 때까지' DFS를 시전한다.
# 그래서 제일 늑대를 적게 만난 루트를 선택한다.
# 그 후 늑대값 추가해주고, 그 루트에서 이어져 있는 노드까지 큐에 넣는다.
# 다시 탐색한다.
# 뭐 이런 방식으로 코드 구현하면 좋을 거 같은데?
# 만약 다 돌았는데 이을 수 있는 노드가 없다? 그럼 현재 값 리턴하면됨!
# 걍 다 탐색하는 게 맞을지도?
# 방법 2. 할 수 있는 모든 노드들 재귀로 탐색하기 = 메모리 터질듯
def dfs(start):
    sheeps = 1
    wolves = 0
    stk = []
    stk.append(start)
    while stk:
        x = stk.pop()
        for node in 노드딕[x]:
            pass


def solution(info, edges):
    노드수 = len(info)
    노드딕 = {i:[] for i in range(노드수)}
    for 시작, 끝 in edges:
        노드딕[시작].append(끝)

    answer = 0
    return answer

print(solution([0,0,1,1,1,0,1,0,1,0,1,1],[[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]]))
print(solution([0,1,0,1,1,0,1,0,0,1,0], [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]]))

# DFS 구현할 때 생각할 점
# 리프노드 일 경우, 값만 더하고 스택에 추가하지 말 것