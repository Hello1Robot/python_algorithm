# 화살을 몇 번 쏘았는지를 알려주는 n
# 어피치가 맞춘 과녘을 표시해주는 info
# 어떻게 최고점수를 낼 수 있을까
# 상대방의 점수를 뺏는다 = 두배의 값을 얻는다 라고 생각할 수 있음
# 화살 한 발 당 낼 수 있는 가장 큰 기대점수가 있음
# 약간 배낭채우는 문제같은 느낌도 드네
# DP쪽으로 접근하는게 맞을듯?
# 1번 테스트 케이스를 생각해보면
# 10점: 3발 필요 - 기대점수 6.666
# 9점 : 2발 필요 - 기대점수 9
# 8점 : 2발 필요 - 기대점수 8
# 7점 : 2발 필요 - 기대점수 7
# 6점 : 1발 필요 - 기대점수 6

# 기대점수 높은 순으로 조진다.
# n이 되는대로 한다.
# 이런 방식으로 하면, 9점2발 - 8점2발 - 6점1발 로 테스트케이스 해답

# 이 방식으로 하면 
# 라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요.
# 이게 걸림...
# 기대점수 큰 걸 먼저하는 건 맞는거 같은데

def solution(n, info):
    기대값 = [[] for _ in range(11)]
    for i in range(10):
        if info[i]:
            값 = ((10-i)*2)/(info[i]+1)
            기대값[i].append((값, (info[i]+1)))
        else:
            기대값[i].append(((10-i),1))
            

    answer = []
    return 기대값


print(solution(5, [2,1,1,1,0,0,0,0,0,0,0]))
solution(1, [1,0,0,0,0,0,0,0,0,0,0])
solution(9, [0,0,1,2,0,1,1,1,1,1,1])

# 2, [01100000000] 이라는 심각한 반례가 등장하여 폐기처분.
# 브루트포스로 어떻게 짤 지 생각해봐야 할 듯 싶음.